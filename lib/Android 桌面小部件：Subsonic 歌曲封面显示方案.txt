Android 桌面小部件：Subsonic 歌曲封面显示方案

要让 Android 桌面小部件显示当前播放歌曲的封面，核心需要解决 封面图片获取、原生小部件图片渲染、Flutter 与原生的封面数据同步 三个问题。以下是结合你的 Subsonic 播放器场景的完整实现方案：

一、核心思路梳理

1. 封面来源：Subsonic API 返回的歌曲/专辑信息中包含封面图片的 URL（如 coverArt 字段）；

2. 图片处理：

  - Flutter 端播放歌曲时，下载封面图片并保存到 Android 本地存储（或通过 MethodChannel 传递封面 URL 给原生）；

  - 原生小部件通过 Glide/Picasso 加载本地图片/网络图片，渲染到 ImageView；

3. 更新触发：播放状态变化（切歌）时，Flutter 主动通知原生更新小部件封面。

二、步骤1：修改小部件布局（添加封面 ImageView）

编辑 res/layout/widget_music_player.xml，在歌曲信息上方添加封面展示区域：

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    android:orientation="vertical"
    android:background="?android:colorBackground">

    <!-- 封面 + 歌曲信息 横向布局 -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:layout_marginBottom="8dp">

        <!-- 歌曲封面 -->
        <ImageView
            android:id="@+id/iv_cover"
            android:layout_width="80dp"
            android:layout_height="80dp"
            android:scaleType="centerCrop"
            android:src="@drawable/ic_default_cover" <!-- 默认封面 -->
            android:layout_marginRight="12dp"/>

        <!-- 歌曲信息 -->
        <LinearLayout
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:orientation="vertical">

            <TextView
                android:id="@+id/tv_song_title"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="16sp"
                android:textStyle="bold"
                android:maxLines="1"
                android:ellipsize="end"
                android:text="暂无播放歌曲"/>

            <TextView
                android:id="@+id/tv_artist"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="14sp"
                android:maxLines="1"
                android:ellipsize="end"
                android:text="未知艺术家"/>
        </LinearLayout>
    </LinearLayout>

    <!-- 播放控制按钮（原有代码不变） -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="12dp"
        android:gravity="center"
        android:orientation="horizontal">
        <!-- 上一曲/播放暂停/下一曲按钮 -->
    </LinearLayout>
</LinearLayout>

- 新增 ic_default_cover 作为默认封面（可放一张空白/默认音乐图标到 res/drawable 目录）；

- 封面尺寸设为 80x80dp，适配小部件整体比例。

三、步骤2：原生端集成图片加载库（Glide）

桌面小部件无法直接使用 ImageView.setImageBitmap() 加载网络图片，需用 Glide 的 AppWidgetTarget 适配小部件渲染：

1. 添加 Glide 依赖（android/app/build.gradle）

在 dependencies 块中添加：

dependencies {
    // 其他依赖...
    implementation 'com.github.bumptech.glide:glide:4.16.0'
    annotationProcessor 'com.github.bumptech.glide:compiler:4.16.0'
}

2. 封装封面加载工具类

新建 kotlin/com/example/minemusic/widget/CoverLoader.kt：

package com.example.minemusic.widget

import android.appwidget.AppWidgetManager
import android.content.Context
import android.widget.RemoteViews
import com.bumptech.glide.Glide
import com.bumptech.glide.request.target.AppWidgetTarget
import com.bumptech.glide.request.transition.Transition
import com.example.minemusic.R

/**
 * 小部件封面加载工具
 * @param context 上下文
 * @param appWidgetId 小部件ID
 * @param remoteViews 小部件布局
 */
class CoverLoader(
    private val context: Context,
    private val appWidgetId: Int,
    private val remoteViews: RemoteViews
) {
    // Glide 适配小部件的 Target
    private val appWidgetTarget = object : AppWidgetTarget(context, R.id.iv_cover, remoteViews, appWidgetId) {
        override fun onResourceReady(resource: android.graphics.Bitmap, transition: Transition<in android.graphics.Bitmap>?) {
            super.onResourceReady(resource, transition)
            // 加载完成后刷新小部件
            AppWidgetManager.getInstance(context).updateAppWidget(appWidgetId, remoteViews)
        }
    }

    /**
     * 加载封面图片
     * @param coverUrl 封面URL（Subsonic的coverArt地址）
     */
    fun loadCover(coverUrl: String?) {
        if (coverUrl.isNullOrEmpty()) {
            // 无封面时显示默认图
            remoteViews.setImageViewResource(R.id.iv_cover, R.drawable.ic_default_cover)
            return
        }

        // 拼接完整的Subsonic封面URL（需带上认证参数）
        val fullCoverUrl = buildFullCoverUrl(coverUrl)

        // Glide 加载网络图片到小部件 ImageView
        Glide.with(context.applicationContext)
            .asBitmap()
            .load(fullCoverUrl)
            .error(R.drawable.ic_default_cover) // 加载失败显示默认图
            .into(appWidgetTarget)
    }

    /**
     * 拼接Subsonic封面的完整URL（带认证参数）
     * 你的Subsonic API需包含u=用户名&p=密码&v=1.16.1&c=MineMusic等参数
     */
    private fun buildFullCoverUrl(coverId: String): String {
        // 从SharedPreferences读取Subsonic配置（你需要提前保存）
        val sp = context.getSharedPreferences("subsonic_config", Context.MODE_PRIVATE)
        val baseUrl = sp.getString("base_url", "http://192.168.2.164:4533") ?: ""
        val username = sp.getString("username", "otoya") ?: ""
        val password = sp.getString("password", "486952") ?: ""

        // Subsonic coverArt API格式：{baseUrl}/rest/getCoverArt.view?id={coverId}&u={user}&p={pass}&v=1.16.1&c=MineMusic&f=json
        return "$baseUrl/rest/getCoverArt.view?id=$coverId&u=$username&p=$password&v=1.16.1&c=MineMusic&f=json"
    }
}

四、步骤3：修改小部件Provider，集成封面加载

编辑 MusicWidgetProvider.kt，在 updateAppWidget 方法中添加封面加载逻辑：

// 补充import
import android.content.SharedPreferences

// 更新小部件UI的核心方法
private fun updateAppWidget(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetId: Int
) {
    val remoteViews = RemoteViews(context.packageName, R.layout.widget_music_player)

    // 1. 点击小部件空白区域打开APP（原有逻辑）
    val intent = Intent(context, MainActivity::class.java)
    val pendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
    remoteViews.setOnClickPendingIntent(R.id.widget_root, pendingIntent)

    // 2. 加载播放状态（当前歌曲、艺术家、封面）
    val sp = context.getSharedPreferences("play_state", Context.MODE_PRIVATE)
    val songTitle = sp.getString("current_song_title", "暂无播放歌曲") ?: ""
    val artist = sp.getString("current_artist", "未知艺术家") ?: ""
    val coverId = sp.getString("current_cover_id", "") ?: "" // Subsonic的coverArt ID

    // 设置歌曲信息
    remoteViews.setTextViewText(R.id.tv_song_title, songTitle)
    remoteViews.setTextViewText(R.id.tv_artist, artist)

    // 3. 加载封面图片
    CoverLoader(context, appWidgetId, remoteViews).loadCover(coverId)

    // 4. 设置播放控制按钮的点击事件（原有逻辑）
    setControlButtonClickEvents(context, remoteViews)

    // 更新小部件
    appWidgetManager.updateAppWidget(appWidgetId, remoteViews)
}

// （原有代码）设置控制按钮点击事件
private fun setControlButtonClickEvents(context: Context, remoteViews: RemoteViews) {
    // 上一曲
    val prevIntent = Intent(ACTION_PREV).apply { setPackage(context.packageName) }
    val prevPendingIntent = PendingIntent.getBroadcast(context, 1, prevIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
    remoteViews.setOnClickPendingIntent(R.id.btn_prev, prevPendingIntent)

    // 播放/暂停
    val playPauseIntent = Intent(ACTION_PLAY_PAUSE).apply { setPackage(context.packageName) }
    val playPausePendingIntent = PendingIntent.getBroadcast(context, 2, playPauseIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
    remoteViews.setOnClickPendingIntent(R.id.btn_play_pause, playPausePendingIntent)

    // 下一曲
    val nextIntent = Intent(ACTION_NEXT).apply { setPackage(context.packageName) }
    val nextPendingIntent = PendingIntent.getBroadcast(context, 3, nextIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
    remoteViews.setOnClickPendingIntent(R.id.btn_next, nextPendingIntent)
}

四、步骤4：Flutter 端同步播放状态（封面ID/歌曲信息）

Flutter 播放歌曲时，通过 MethodChannel 将当前歌曲的 标题、艺术家、封面ID 同步到 Android 原生的 SharedPreferences，触发小部件更新：

1. Flutter 端 MethodChannel 封装

// lib/utils/native_channel.dart
import 'package:flutter/services.dart';

class NativeChannel {
  static const MethodChannel _channel = MethodChannel('mine_music/widget');

  /// 同步播放状态到原生（供小部件读取）
  static Future<void> syncPlayState({
    required String songTitle,
    required String artist,
    required String coverId, // Subsonic返回的coverArt ID
    required bool isPlaying,
  }) async {
    try {
      await _channel.invokeMethod('syncPlayState', {
        'songTitle': songTitle,
        'artist': artist,
        'coverId': coverId,
        'isPlaying': isPlaying,
      });
    } catch (e) {
      print('同步播放状态失败: $e');
    }
  }

  /// 触发小部件更新
  static Future<void> updateWidget() async {
    try {
      await _channel.invokeMethod('updateWidget');
    } catch (e) {
      print('更新小部件失败: $e');
    }
  }
}

2. 播放歌曲时调用同步方法

在你的 Flutter 播放逻辑中（如播放页、播放服务），切换歌曲时调用：

// 示例：播放歌曲时同步状态
void playSong(SongModel song) async {
  // 1. 播放歌曲逻辑（原有代码）
  await audioPlayer.play(Uri.parse(song.playUrl));

  // 2. 同步状态到原生
  await NativeChannel.syncPlayState(
    songTitle: song.title,
    artist: song.artist,
    coverId: song.coverArtId, // Subsonic返回的coverArt字段
    isPlaying: true,
  );

  // 3. 触发小部件更新
  await NativeChannel.updateWidget();
}

3. Android 原生处理 MethodChannel 调用

编辑 MainActivity.kt，添加 MethodChannel 处理逻辑：

package com.example.minemusic

import android.content.Context
import android.content.SharedPreferences
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel
import android.appwidget.AppWidgetManager
import android.content.ComponentName
import com.example.minemusic.widget.MusicWidgetProvider

class MainActivity : FlutterActivity() {
    private val CHANNEL = "mine_music/widget"
    private lateinit var playStateSP: SharedPreferences

    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        // 初始化SharedPreferences（保存播放状态）
        playStateSP = getSharedPreferences("play_state", Context.MODE_PRIVATE)

        // 注册MethodChannel
        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result ->
            when (call.method) {
                // 同步播放状态
                "syncPlayState" -> {
                    val songTitle = call.argument<String>("songTitle") ?: ""
                    val artist = call.argument<String>("artist") ?: ""
                    val coverId = call.argument<String>("coverId") ?: ""
                    val isPlaying = call.argument<Boolean>("isPlaying") ?: false

                    // 保存到SharedPreferences
                    playStateSP.edit()
                        .putString("current_song_title", songTitle)
                        .putString("current_artist", artist)
                        .putString("current_cover_id", coverId)
                        .putBoolean("is_playing", isPlaying)
                        .apply()

                    result.success(true)
                }
                // 更新小部件
                "updateWidget" -> {
                    val appWidgetManager = AppWidgetManager.getInstance(this)
                    val componentName = ComponentName(this, MusicWidgetProvider::class.java)
                    // 触发所有小部件更新
                    appWidgetManager.notifyAppWidgetViewDataChanged(
                        appWidgetManager.getAppWidgetIds(componentName),
                        R.id.widget_root
                    )
                    appWidgetManager.updateAppWidget(componentName, null)
                    result.success(true)
                }
                else -> {
                    result.notImplemented()
                }
            }
        }
    }
}

五、关键注意事项

1. Subsonic 封面 URL 认证：

  - Subsonic 的 getCoverArt.view API 必须带上用户认证参数（u/p/c/v），否则会返回 401；

  - 建议将 Subsonic 配置（baseUrl/用户名/密码）保存到 SharedPreferences，避免硬编码。

2. 图片缓存优化：

  - Glide 会自动缓存封面图片，减少重复网络请求；

  - 若封面加载慢，可在 Flutter 端提前下载封面并保存到本地，原生直接加载本地图片。

3. 权限适配：

  - 若加载网络封面，需在 AndroidManifest.xml 添加网络权限：

<uses-permission android:name="android.permission.INTERNET"/>

  - Android 10+ 需注意网络请求的 Cleartext Traffic（若使用 http 协议，需在 AndroidManifest.xml 的 application 标签添加：

android:usesCleartextTraffic="true"

4. PendingIntent 兼容性：

  - Android 12+ 需给 PendingIntent 添加 FLAG_IMMUTABLE 标志（代码中已包含）。

六、测试验证

1. 播放一首有封面的歌曲，Flutter 端调用 syncPlayState 同步封面 ID；

2. 桌面小部件会自动加载并显示封面图片；

3. 切歌时，Flutter 重新同步封面 ID，小部件自动刷新新封面；

4. 无封面/加载失败时显示默认封面。

通过以上步骤，你的桌面小部件就能完整显示当前播放歌曲的封面，且与 Flutter 播放逻辑实时同步。
